<!doctype html>

<html lang="en">
<head>
	<meta charset="utf-8">

	<title>Inscribed square problem</title>

	<style>
		html, body {
		    overflow: hidden;
		    margin: 0 !important;
		    padding: 0 !important;
		}
	</style>
</head>

<body>
	<canvas id="canvas"></canvas>
	<script src="http://izanbf.es/js/rough.min.js"></script>
	<script>
		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');
		canvas.width  = window.innerWidth;
		canvas.height = window.innerHeight;

		const rc = rough.canvas(canvas);

		const eps = 1e-5;

		let points = [];
		let drawing = false;
		let finished = false;

		let mobileLastX = 0;
		let mobileLastY = 0;

		let clear = () => {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
		};

		let pointToStr = (pt) => {
			return pt[0].toString() + "," + pt[1].toString();
		};

		let pointsToPath = (pts) => {
			let path = "M " + pointToStr(pts[0]);
			for (let i = 1; i < pts.length; ++i) {
				path += " L " + pointToStr(pts[i]);
			}
			return path;
		};

		let drawCurve = (fill) => {
			if (points.length >= 2) {
				let path = pointsToPath(points);
				let params = { simplification: 1, roughness: 0, hachureGap: 6, hachureAngle: 60 };
				if (fill != null) {
					params.fill = fill;
				}
				rc.path(path, params);
			}
		};

        let addLinePoints = (pts) => {
            let pts2 = [];
            let n = pts.length;
            let total_dist = 0;
            for (let i = 0; i < n-1; ++i) {
                total_dist += dist(pts[i], pts[i+1]);
            }
            for (let i = 0; i < n-1; ++i) {
                let A = pts[i];
                let B = pts[i+1];
                let d = dist(A, B);

                if (d > 1) {
                    pts2.push(A);

                    let C = A;
                    let v = vec(A, B);
                    let f = 1000*d/total_dist;
                    v[0] /= f;
                    v[1] /= f;

                    C = vecAdd(C, v);

                    while (dist(A, C) < d) {
                        pts2.push(C);
                        C = vecAdd(C, v);
                    }
                }
            }  
            return pts2; 
        };

		let vecDiff = (U, V) => {
			return [U[0]-V[0], U[1]-V[1]];
		};

		let vecAdd = (U, V) => {
			return [U[0]+V[0], U[1]+V[1]];
		};

		let vecDot = (U, V) => {
			return U[0]*V[0] + U[1]*V[1];
		};

		let vecNorm = (V) => {
			return vecDot(V, V);
		};

		let dist = (A, B) => {
			return Math.sqrt(vecNorm(vecDiff(A, B)));
		};

		let vecEq = (U, V) => {
			return dist(U, V) < eps;
		};

		let pointEq = (A, B) => {
			return dist(A, B) < 3;
		};

		let vec = (A, B) => {
			return vecDiff(B, A);
		};

		let rotate = (V, ang) => {
			let x = V[0];
			let y = V[1];
			let sin = Math.sin(ang);
			let cos = Math.cos(ang);
			let rx = x * cos - y * sin;
			let ry = x * sin + y * cos;
			return [rx, ry];
		};

		let square = (A, B) => {
			let v = vec(A, B);
			v = rotate(v, 3*Math.PI/2);
			let C = vecAdd(B, v);
			v = rotate(v, 3*Math.PI/2);
			let D = vecAdd(C, v);
			return [A, B, C, D];
		}

		let solveProblem = (pts) => {
			let n = pts.length;
			for (let i = 0; i < n; ++i) {
				for (let j = 0; j < n; ++j) {
					let A = pts[i];
					let B = pts[j];
					let d = dist(A, B);
					if (d < 10) continue;
					
					let sq = square(A, B);
					let C = sq[2];
					let D = sq[3];

					let Cfound = false;
					let Dfound = false;

					for (let k = 0; k < n; ++k) {
						let P = pts[k];
						if (pointEq(P, C)) {
							Cfound = true;
						}
						if (pointEq(P, D)) {
							Dfound = true;
						}
					}

					if (Cfound && Dfound) {
						return sq;
					}
				}
			}
			return null;
		};

		let reset = () => {
			clear();
			points = [];
			drawing = false;
			finished = false;
		};

		let onMouseDown = (x, y) => {
			if (finished) {
				reset();
			}
			drawing = true;
		};

		let onMouseUp = (x, y) => {
			points.push(points[0]);
            points = addLinePoints(points);
			clear();
			drawCurve("rgba(0,0,255,0.5)");
			drawing = false;
			console.log(points.length);
			let sq = solveProblem(points);
			if (sq == null) {
				alert("Vaya, el algoritmo ha fallado, prueba de nuevo");
				reset();
			}
			else {
				for (let i = 0; i < 4; ++i) {
					rc.circle(sq[i][0], sq[i][1], 10, { fill: "red", roughness: 0, fillStyle: "solid" });
				}
				rc.polygon(sq, { fill: "rgba(255,0,200,0.2)", roughness: 0, fillStyle: "solid" });
				finished = true;
			}
		};

		let onMouseMove = (x, y) => {
			rc.circle(x, y, 10, { fill: "red", roughness: 0, fillStyle: "solid" });
			if (drawing) {
				points.push([x, y]);
				clear();
				drawCurve(null);
			}
		};

		// https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser
		window.mobileCheck = function() {
		  let check = false;
		  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
		  return check;
		};

		if (window.mobileCheck()) {
			canvas.addEventListener("touchmove", e => {
				e.preventDefault();
				for (let i = 0; i < e.touches.length; ++i) {
					let x = e.touches[i].clientX;
					let y = e.touches[i].clientY;
					if (!drawing) {
						onMouseDown(x, y);
					}
					else {
						onMouseMove(x, y);
					}
					mobileLastX = x;
					mobileLastY = y;
				}
			});
			
			canvas.addEventListener("touchend", e => {
				e.preventDefault();
				onMouseUp(mobileLastX, mobileLastY);
			});
		}
		else {
			canvas.addEventListener("mousedown", e => {
				onMouseDown(e.clientX, e.clientY);
			});

			canvas.addEventListener("mouseup", e => {
	            onMouseUp(e.clientX, e.clientY);
			});

			canvas.addEventListener("mousemove", e => {
				onMouseMove(e.clientX, e.clientY);
			});
		}
	</script>
</body>
</html>